---
title: "OS Notes: UNIX"
date: 2020-04-15T12:11:28+08:00
---

## Processes

The Linux kernel internally represents processes as __tasks__, via the structure _task_struct_. Linux uses the task structure to represent any execution context.

For each process, a process descriptor of type _task\_struct_ is resident in memory at all times. It contains vital information needed for the kernel's management of all processes. The process descriptor along with memory for the kernel-mode stack for the process are created upon process creation.

For compatibility with other UNIX systems, Linux identifies processes via the PID. The kernel organizes all processes in a bidirectional linked-list of task structures. The PID can be mapped to the address of the task structure in order to access the info directly.

The task structure contains a variety of fields. Some of these fields contain pointers to other data structures or segments, which may be related to the user-level structure of the process, which is not interest when the user process is not runnable. Thereforce, these may be swapped or paged in order not to waste memory. However, info about signals must be in memory all the time, even when the process is not present in memory, while file descriptors can be kept in the user structure and brought in only when the process is in memory and runnable.

The info in the process descriptor falls into a number of broad categories that can be roughly described as follows:

- __Scheduling parameters__ which are used to determine which process to run next.
- __Memory image__ with pointers to the text, data, and stack segments, or page tables.
- __Signals__.
- __Machine registers__ are used to save registers when a trap to the kernel occurs.
- __System call state__.
- __File descriptor table__.
- __Accounting__ as a pointer to a table that keeps track of the user and system CPU time used by the process and other info.
- __Kernel stack__ is a fixed stack for use by the kernel part of the process.
- __Miscellaneous__. Current process state, PID, parent process PID, user and group identification and so on.

When a __fork__ system call is executed, the calling process traps to the kernel and creates a task structure and few other accompanying data structures, such as kernel-mode stack and a _thread\_info_ structure. This structure is allocated at a __fixed__ offset from the process' end-of-stack, and contains few process parameters, along with the address of the process descriptor.

The majority of the process descriptor contents are filled out based on the parent's descriptor values. The system then looks for an available PID and updated the PID hash-table entry to point to the new task structure. It also sets the fileds in the _task\_struct_ to point to the previous/next process on the task array.

Here with the mechanism called __copy on write__, the child process is given its own page tables, but have them point to the parent's pages, only marked read only. Whenever either parent/child process tries to write on a page, it gets a protection fault. The kernel then allocates a new copy of the page to the faulting process and marks it read/write.

When a __exec__ system call is executed then, the kernel finds and verifies the executable file, copies the arguments and enviroment strings to the kernel, and releases the old address space and its page table. Now the new address space must be created and filled in. If the system supports mapped files, the new page tables are set up to indicate that no pages are in memory, except perhaps one stack page, but that the address space is backed by executable file on disk. When the new process starts running, it will get a page fault, which will cause the first page of code to be paged in from the executable file. In this way, nothing has to be loaded in advance, so programs can start quickly and fault in just those pages they need and no more. Finally, the arguments and environment strings are copied to the new stack, the signals are reset, and the registers are initialized to all zeros.

![image-20200416165952200](https://i.loli.net/2020/04/16/ZqVB3yaeovKOSUL.png)

### Threads

Here just focus on kernel threds in Linux, particalarly on the differences among the Linux thread model and other Unix systems. There are several challenging decisions present.

Linux introduced a powerful new system call, __clone__, that blurred the distinction between processes and threads. The signature is as follws:

```c++
int clone(int (*fn)(void *), void *stack, int flags, void *arg);
// return pid
```

The _flags_ parameter is a bitmap that allows a finer grain of sharing than UNIX systems. Each of the bits can be set indelendently of the other ones.

